{"componentChunkName":"component---src-templates-blog-post-js","path":"/garbage-collector-impl/","result":{"data":{"site":{"siteMetadata":{"title":"Java Performace"}},"markdownRemark":{"id":"95a0015a-fd06-5d73-a67d-365fbd7cb54e","excerpt":"The garbage collection is the principal bottleneck, it’s useful to understand some aspects of the implementation. Garbage collectors make assumptions about the…","html":"<p>The garbage collection is the principal bottleneck, it’s useful to understand some aspects of the implementation. Garbage collectors make assumptions about the way applications use objects, and these are reflected in tunable parameters that can be adjusted for improved performance without sacrificing the power of the abstraction.</p>\n<h2>Generational Garbage Collection</h2>\n<p>An object is considered garbage and its memory can be reused by the VM when it can no longer be reached from any reference of any other live object in the running program.</p>\n<p>The JVM incorporates a number of different garbage collection algorithms that all use a technique called generational collection. The most important property is the weak generational hypothesis, which states that most objects survive for only a short period of time.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 543px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/JPerformance/static/b82c510e3bc3b18dccd4abfe1a4ea291/29579/blue.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.82278481012659%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSElEQVQoz52Q3U7CQBBG+/5PQ4BLL0wkFig1GBMklrRQaLfdbv9tLd3ZGdNGlKiJ4JfJXuzOyXeyGgAgIhHt+liWFYYhEWEfIkqSxLZty7IcxwEAOgURtbIsq7cGAJQCdcr5EhH9vEFEANBCka62EaGSHd8tAYCU8k9YSqltPW5anAilhM/aS5o7eM/E0hZE2Jtfqe0y8bCJiNR586XaLhOmFXXa8A/tIF6cYLhW294Hxgsn7J7x2t++N5b6mhOpsm5EUbetVEq1UiLSx5zB2M8XvFg+DeeHm0d/bBxGhjdZ8WMridS3HqXUL9r63ByZwdDwxgt/MHMH0+1sHTy7YuNnTpA7QR6mVZy/BnGeFHVa1IeosFlWN8emabQ0y24n+p0+n0yNvc8ZT1wmth7f+ZHLhMuEF8ZBFPvdmTCeeGHshXGS5lVVvQOpveyz75aqyQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Memory\"\n        title=\"Memory\"\n        src=\"/JPerformance/static/b82c510e3bc3b18dccd4abfe1a4ea291/29579/blue.png\"\n        srcset=\"/JPerformance/static/b82c510e3bc3b18dccd4abfe1a4ea291/c26ae/blue.png 158w,\n/JPerformance/static/b82c510e3bc3b18dccd4abfe1a4ea291/6bdcf/blue.png 315w,\n/JPerformance/static/b82c510e3bc3b18dccd4abfe1a4ea291/29579/blue.png 543w\"\n        sizes=\"(max-width: 543px) 100vw, 543px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\r\nThe blue area in  the image is the typical distribution for the lifetimes of objects.The x-axis is the total bytes in objects with the corresponding lifetime.The sharp peak at the the left represents objects that be reclaimed shortly after being allocated so it focus in the assumption that a majority of objects “die young”.</p>\n<h3>Generations</h3>\n<p>To optimaze for this scenario, memory is managed in  generations(memory pools holding objects of different ages).\r\nGarbage collection occurs in each generation when the generation fills up.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/JPerformance/static/9a70a64d916e81165e93bd1f5b256c7e/7f664/memorySections.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.21518987341772%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQY0yXIUU+CQAAAYH50r/2BXtxaD64Hc3OGazKmqRMljdlEJMzUpcLQhqBMUOHgOE7ibKvH76MIISlJU5ISQsiF/JNcSBjCCCEUxyiO8fnsef5qvcZJgnHyFwkAASXIgjJXtq6lGqqyUmRdnu8W4Y/PdqSbh0a++sbwckuciZ/aTNtwQ62pGIOlrZony/GobDHLtJipPuUHfEWs0DzdVtp+esjXXq8y5UzxJVfts91xZ7gYLc17pksLam95/LLAzsNU4blQapa4PsdJXGPUqL/X+5r4fdLzNf76jr195HNs76kl1YRxW5yVu5OqtO5MtiPdmRtHytyazsFxj65hbT6mY9ux/cB33L29dzwAPRD6AQQBBGEEQggRhvEZIhwhHMX4F3/W/TUz3Y5xAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Memory\"\n        title=\"Memory\"\n        src=\"/JPerformance/static/9a70a64d916e81165e93bd1f5b256c7e/7f664/memorySections.png\"\n        srcset=\"/JPerformance/static/9a70a64d916e81165e93bd1f5b256c7e/c26ae/memorySections.png 158w,\n/JPerformance/static/9a70a64d916e81165e93bd1f5b256c7e/6bdcf/memorySections.png 315w,\n/JPerformance/static/9a70a64d916e81165e93bd1f5b256c7e/7f664/memorySections.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\r\nAt the startup, the VM reserves the entire Java heap in the address space, but doesn’t allocate any physical memory for it unless needed, the space is logically divided into young and old generations.</p>\n<p>The Young generation consists of eden and two survivor spaces. Most objects are initially allocated in the eden. One survior space is empty at any time, and serves as the destination of live objects in eden and the other survivor space during garbage collection, after a garbage collection, eden and the survivor space are empty.In the next garbage collection, the purpose of the two survivor spaces are exchanged. The one space recently filled is a source of live objects that copied into the other survivor space.Objects are copied between survivor spaces in this way until they’ve been copied a certain number of times or there isn’t enough space left there. These objects are copied into the old region. This process is also called aging.</p>\n<h3>Performance Considerations</h3>\n<p>The primary measures of the garbage collection are throughput and latency.\r\n.Throughput is the percentage of total time not spent in garbage collection considered over long periods of time.\r\n.Latency is the responsiveness of an application. Consider the right metric for a web server to be throughput because pauses during garbage collection may be tolerable, obscured by network latencies. However in an interactive graphics program, even short pauses affect the user experience.</p>\n<h3>Throughput and Footprint Measurement</h3>\n<p>Throughput and footprint are best measured using metrics particular to the application.\r\nFor example, the throughput of a web server may be tested using a client load generator.\r\nAlso in the VM logs with the command <strong>“-verbose:gc”</strong> prints information about the heap andgarbage collection at each collection for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M->57M(307M) (15,646s, 15,651s) 5,048ms.\r\n[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M->57M(307M) (16,146s, 16,162s) 16,565ms.\r\n[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M->31M(104M) (16,202s, 16,367s) 164,581ms</code></pre></div>\n<p>The output shows two young generations followeb by a full collection bacause of the <strong>“System.gc()”</strong> call.</p>\n<p>The first line shows 239M->57M(307M), which means that 239M were usef before the GC and the GC cleared up most of the memory, but 57MB survived. The heap size is 307M, note that the full GC shrinks the heap from 307 MB to 104 MB, the start and end times for the GC are logged as well as the duration (end-start).</p>","frontmatter":{"title":"Garbage Collector implementation","date":"June 26, 2021","description":"The garbage collection is the principal bottleneck, it's useful to understand some aspects of the implementation"}},"previous":{"fields":{"slug":"/jvm-ergonomics/"},"frontmatter":{"title":"JVM Ergonomics"}},"next":{"fields":{"slug":"/factors-Affecting-Garbage-collection-Performance/"},"frontmatter":{"title":"Factors Affecting Garbage Collection Performance"}}},"pageContext":{"id":"95a0015a-fd06-5d73-a67d-365fbd7cb54e","previousPostId":"f5a64c0c-2575-58d5-860a-b0ad6931dada","nextPostId":"c1b9194b-f2a8-52a4-abc1-6a382418872b"}},"staticQueryHashes":["2841359383","3257411868"]}